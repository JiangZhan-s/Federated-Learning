# FedAvg 项目代码编写顺序建议

本文档为你提供了一个清晰的、分阶段的 FedAvg 项目代码编写顺序。遵循此顺序可以帮助你从底层模块开始，逐步构建一个完整、清晰且易于维护的联邦学习系统。

---

## **第一阶段：基础模块定义**

### 1. **配置 (`config/fedavg.yaml`)**

*   **目标**: 定义项目的所有可调参数。
*   **操作**: 在 `fedavg.yaml` 文件中，用 YAML 格式写下联邦学习的超参数，例如：学习率、全局通信轮次、每轮参与的客户端比例、本地训练的 epoch 数、数据集名称等。这是所有后续模块的“指挥中心”。

### 2. **数据处理 (`src/data/`)**

*   **目标**: 准备和分发数据集。
*   **操作**:
    *   在 `dataset.py` 中，编写加载标准数据集（如 MNIST 或 CIFAR-10）的代码。
    *   在 `preprocessing.py` 中，实现数据预处理（如归一化、转换）以及最重要的**数据划分逻辑**。你需要将数据集模拟分配给多个客户端，并考虑 IID（独立同分布）和 Non-IID（非独立同分布）两种情况。

### 3. **模型架构 (`src/models/model.py`)**

*   **目标**: 定义用于训练的神经网络模型。
*   **操作**: 使用 PyTorch 或 TensorFlow/Keras 定义一个模型类。对于初学者，一个简单的卷积神经网络（CNN）就足够了。

---

## **第二阶段：核心联邦逻辑**

### 4. **本地训练器 (`src/training/trainer.py`)**

*   **目标**: 封装单个客户端的训练过程。
*   **操作**: 创建一个 `Trainer` 类，它接收一个模型、一部分数据和一个优化器。这个类需要有一个 `train()` 方法，负责在本地数据集上执行指定轮次（local epochs）的训练。

### 5. **客户端 (`src/federation/client.py`)**

*   **目标**: 模拟一个参与联邦学习的客户端。
*   **操作**: 创建一个 `Client` 类。每个 `Client` 实例都拥有自己的本地数据和上面定义的 `Trainer`。它需要实现一个核心方法，例如 `update_model(global_model)`，该方法接收来自服务器的全局模型，使用本地数据进行训练，并返回更新后的本地模型权重。

### 6. **聚合算法 (`src/federation/aggregator.py`)**

*   **目标**: 实现 FedAvg 核心的加权平均算法。
*   **操作**: 编写一个函数或类，输入是多个客户端上传的模型权重（以及它们的数据量），输出是聚合后的新全局模型权重。

---

## **第三阶段：整体流程串联**

### 7. **联邦策略 (`src/federation/strategies.py`)**

*   **目标**: 定义一轮联邦学习的具体流程。
*   **操作**: 创建一个策略类（例如 `FedAvgStrategy`），它负责协调一轮完整的操作：选择客户端、分发模型、触发客户端训练、收集更新、调用聚合器。这有助于将“如何聚合”与“何时聚合”解耦。

### 8. **中心服务器 (`src/federation/server.py`)**

*   **目标**: 驱动整个联邦学习过程。
*   **操作**: 实现 `Server` 类。这是总控制器，它会：
    *   初始化全局模型。
    *   循环执行指定的全局通信轮次。
    *   在每一轮中，利用 `FedAvgStrategy` 来执行一轮训练和聚合。
    *   （可选）在每轮结束后，在全局测试集上评估模型性能并记录日志。

### 9. **主入口 (`src/main.py` 和 `scripts/run_federated_simulation.py`)**

*   **目标**: 启动并运行整个模拟。
*   **操作**:
    *   在 `main.py` 中，编写一个主函数，它会加载配置、准备数据、初始化服务器，并调用服务器的 `run()` 方法来启动整个流程。
    *   `run_federated_simulation.py` 脚本则直接调用 `main.py` 中的主函数，作为程序的最终入口点。

---

按照这个顺序，你的思路会非常清晰，每一步的产出都会成为下一步的输入。祝你编码愉快！
